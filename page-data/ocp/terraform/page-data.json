{"componentChunkName":"component---src-pages-ocp-terraform-index-mdx","path":"/ocp/terraform/","result":{"pageContext":{"frontmatter":{"title":"Terraform","weight":210},"relativePagePath":"/ocp/terraform/index.mdx","titleType":"page","MdxNode":{"id":"b24387d0-bed8-5b9c-82a1-16c9eec23c1d","children":[],"parent":"faad8feb-bc6d-5530-93cf-b0b459cf8f9a","internal":{"content":"---\ntitle: Terraform\nweight: 210\n---\n\n## Terraform Introduction and Motivation\n\nTerraform is an open source infrastructure automation tool, which can be \ninstalled from `https://terraform.io`. Using it, infrastructure can be \ndeclaratively specified, deployed, updated and versioned. The declarative \ndefinition of infrastructure resources is sometimes called \"infrastructure as \ncode\". These declarations enable the same infrastructure setup to be reproduced \nto different instances and even different underlying infrastructure. This \ncapability allows easy and reproduceable infrastructure environment deployment. \n\nAs there are many terraform providers for cloud infrastructure vendors, \nterraform skills can be transferred between cloud providers to build platforms \non multiple clouds.\n\nTerraform is a useful tool for building *immutable infrastructure*, which is a \nparadigm where infrastructure is never modified after it is deployed.  This \nallows the state of the infrastructure to be completely defined by the declarative \ndefinitions, and destroyed and recreated when problems arise.\n\n### Terraform resources\n\nIn Terraform, a resource is a component of your infrastructure. It could be a \nlow level component such as a physical server, virtual machine, or container. \nIt could also be a higher level component such as an email provider, DNS record, \nor database provider. \n\n### Terraform providers\n\nInfrastructure resources are provisioned by providers. Providers are responsible \nin Terraform for managing the lifecycle of a resource: create, read, update, \ndelete. A provider definition includes the necessary credentials to access the \ninfrastructure. A provider translates the declarative resources specified in the \nterraform language to API calls for the specific provider. Providers generally \nare available for an IaaS (e.g. AWS, GCP, Microsoft Azure, OpenStack), \nPaaS (e.g. Heroku), or \nSaaS service (e.g. Terraform Enterprise, DNSimple, CloudFlare).\n\nTerraform uses provider plugins to generate resources for different \ninfrastructure components. Plugins allow terraform capabilities to be extended \nand new resource classes to be provisioned. The providers and plugins maintained \nby Hashicorp, the creator of Terraform, reside in a set of repositories in the \n`terraform-providers` organization in Github. Third party providers and plugins \ncan also be housed in other Github repositories.\n\n### Terraform project layout\n\nTerraform modules and resource definitions are defined in a set of `*.tf` files. \nA module is a grouping of multiple resources that are used together and deployed \ntogether. The most common set of `*.tf` files you will see in the current \ndirectory from which you run your terraform deployment are as follows:\n - `variables.tf` - This file contains the definitions for all the input \n variables needed to deploy the resources defined in the module. Typically this \n file contains variable declarations only, not variable values.\n - `outputs.tf` - This file defines any output or return value variables that \n will be produced. The output values can be used by another module performing \n the next step of a deployment.\n - `*.tf` - Any additional resources may be in other files with `*.tf` extension. \n The provider plugins that will be used to deploy those resources, the name and \n location of *modules*, each of which contains the definitions and instructions \n to deploy a resource, and necessary variables for those plugins, resources and \n modules. \n - `terraform.tfvars` - This file is configured with the values to apply to \n variables declared in `variables.tf`. This file may contain credentials and \n should not be committed to source control without some type of access controls.\n\n### Terraform execution\n\nBefore execution, prepare the variables file with all required variables as \ndefined in `variables.tf`. Use the `terraform init` command to download all \nrequired terraform providers and modules to the local directory.\n\nUsing the `terraform plan` command, we can check what terraform will do without \nactually making any infrastructure changes, which is helpful to examine what \nwould happen without incurring costs associated with creating or destroying \nresources.\n\nWhen run using the `terraform apply` command, the variable substitutions are \nread from the `.tfvars` file.  Terraform internally generates a dependency \ngraph and will begin provisioning resources in a topological order.\n\n### Terraform state and drift detection\n\nTerraform creates a state file with the `*.tfstate` extension to store the \nresults of resources it has provisioned during every `terraform apply` run.  \nIt uses this file to detect drift, which are differences in the actual \ninfrastructure and terraform's own view of the resources it has created.  \nFor example, if someone has removed a virtual machine after deployment, \nterraform is able to compare its state file with the live state and recreate \nthe virtual machine according to the resource definitions.\n\n### Terraform modules\n\nTerraform modules may be packaged in sub-directories or in separate \ngit repositories for code reuse.  The main \nlogic can be contained in a repo that combines one or more \nmodules to build a full end-to-end solution. Alternatively,\nthe main repo \nmay contain pointers to multiple modules, each of which \nresides in its own github repo. These modules are typically \nself-contained functions that often need to be run in a certain \nsequence. Some of the components may be shared across \ndifferent implementations. \n\n### Using Terraform to install OpenShift 4\n\nWhere requirements dictate a network-restricted installation, or some\nother infrastructure customization outside the capabilities of an \ninstaller-provisioned infrasture (IPI) installation, terraform can\nbe used to automate some or all of the user-provisioned infrastructure (UPI)\ninstallation. \nSample terraform \nscripts are provided in the sections for [AWS](../openshift4_aws/),\n[Azure](../openshift4_azure/), [Google Cloud Platform](../openshift4_gcp/),\nand [VMware](../openshift4_vmware/).","type":"Mdx","contentDigest":"3eb9957690fefbce54d5c00746b0d1bb","counter":495,"owner":"gatsby-plugin-mdx"},"frontmatter":{"title":"Terraform","weight":210},"exports":{},"rawBody":"---\ntitle: Terraform\nweight: 210\n---\n\n## Terraform Introduction and Motivation\n\nTerraform is an open source infrastructure automation tool, which can be \ninstalled from `https://terraform.io`. Using it, infrastructure can be \ndeclaratively specified, deployed, updated and versioned. The declarative \ndefinition of infrastructure resources is sometimes called \"infrastructure as \ncode\". These declarations enable the same infrastructure setup to be reproduced \nto different instances and even different underlying infrastructure. This \ncapability allows easy and reproduceable infrastructure environment deployment. \n\nAs there are many terraform providers for cloud infrastructure vendors, \nterraform skills can be transferred between cloud providers to build platforms \non multiple clouds.\n\nTerraform is a useful tool for building *immutable infrastructure*, which is a \nparadigm where infrastructure is never modified after it is deployed.  This \nallows the state of the infrastructure to be completely defined by the declarative \ndefinitions, and destroyed and recreated when problems arise.\n\n### Terraform resources\n\nIn Terraform, a resource is a component of your infrastructure. It could be a \nlow level component such as a physical server, virtual machine, or container. \nIt could also be a higher level component such as an email provider, DNS record, \nor database provider. \n\n### Terraform providers\n\nInfrastructure resources are provisioned by providers. Providers are responsible \nin Terraform for managing the lifecycle of a resource: create, read, update, \ndelete. A provider definition includes the necessary credentials to access the \ninfrastructure. A provider translates the declarative resources specified in the \nterraform language to API calls for the specific provider. Providers generally \nare available for an IaaS (e.g. AWS, GCP, Microsoft Azure, OpenStack), \nPaaS (e.g. Heroku), or \nSaaS service (e.g. Terraform Enterprise, DNSimple, CloudFlare).\n\nTerraform uses provider plugins to generate resources for different \ninfrastructure components. Plugins allow terraform capabilities to be extended \nand new resource classes to be provisioned. The providers and plugins maintained \nby Hashicorp, the creator of Terraform, reside in a set of repositories in the \n`terraform-providers` organization in Github. Third party providers and plugins \ncan also be housed in other Github repositories.\n\n### Terraform project layout\n\nTerraform modules and resource definitions are defined in a set of `*.tf` files. \nA module is a grouping of multiple resources that are used together and deployed \ntogether. The most common set of `*.tf` files you will see in the current \ndirectory from which you run your terraform deployment are as follows:\n - `variables.tf` - This file contains the definitions for all the input \n variables needed to deploy the resources defined in the module. Typically this \n file contains variable declarations only, not variable values.\n - `outputs.tf` - This file defines any output or return value variables that \n will be produced. The output values can be used by another module performing \n the next step of a deployment.\n - `*.tf` - Any additional resources may be in other files with `*.tf` extension. \n The provider plugins that will be used to deploy those resources, the name and \n location of *modules*, each of which contains the definitions and instructions \n to deploy a resource, and necessary variables for those plugins, resources and \n modules. \n - `terraform.tfvars` - This file is configured with the values to apply to \n variables declared in `variables.tf`. This file may contain credentials and \n should not be committed to source control without some type of access controls.\n\n### Terraform execution\n\nBefore execution, prepare the variables file with all required variables as \ndefined in `variables.tf`. Use the `terraform init` command to download all \nrequired terraform providers and modules to the local directory.\n\nUsing the `terraform plan` command, we can check what terraform will do without \nactually making any infrastructure changes, which is helpful to examine what \nwould happen without incurring costs associated with creating or destroying \nresources.\n\nWhen run using the `terraform apply` command, the variable substitutions are \nread from the `.tfvars` file.  Terraform internally generates a dependency \ngraph and will begin provisioning resources in a topological order.\n\n### Terraform state and drift detection\n\nTerraform creates a state file with the `*.tfstate` extension to store the \nresults of resources it has provisioned during every `terraform apply` run.  \nIt uses this file to detect drift, which are differences in the actual \ninfrastructure and terraform's own view of the resources it has created.  \nFor example, if someone has removed a virtual machine after deployment, \nterraform is able to compare its state file with the live state and recreate \nthe virtual machine according to the resource definitions.\n\n### Terraform modules\n\nTerraform modules may be packaged in sub-directories or in separate \ngit repositories for code reuse.  The main \nlogic can be contained in a repo that combines one or more \nmodules to build a full end-to-end solution. Alternatively,\nthe main repo \nmay contain pointers to multiple modules, each of which \nresides in its own github repo. These modules are typically \nself-contained functions that often need to be run in a certain \nsequence. Some of the components may be shared across \ndifferent implementations. \n\n### Using Terraform to install OpenShift 4\n\nWhere requirements dictate a network-restricted installation, or some\nother infrastructure customization outside the capabilities of an \ninstaller-provisioned infrasture (IPI) installation, terraform can\nbe used to automate some or all of the user-provisioned infrastructure (UPI)\ninstallation. \nSample terraform \nscripts are provided in the sections for [AWS](../openshift4_aws/),\n[Azure](../openshift4_azure/), [Google Cloud Platform](../openshift4_gcp/),\nand [VMware](../openshift4_vmware/).","fileAbsolutePath":"/home/travis/build/ibm-cloud-architecture/cloudpak8s/src/pages/ocp/terraform/index.mdx"}}}}